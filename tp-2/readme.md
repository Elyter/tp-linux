# TP2 : Appr√©hender l'environnement Linux

Dans ce TP, on va aborder plusieurs sujets, dans le but principal de se familiariser un peu plus avec l'environnement GNU/Linux.

> Pour rappel, nous √©tudions et utilisons GNU/Linux de l'angle de l'administrateur, qui g√®re des serveurs. Nous n'allons que tr√®s peu travailler avec des distributions orient√©es client. Rocky Linux est parfaitement adapt√© √† cet usage.

Ce que vous faites dans ce TP deviendra peu √† peu naturel au fil des cours et de votre utilsation de GNU/Linux.

Comme d'hab rien √† savoir par coeur, jouez le jeu, et la plasticit√© de votre cerveau fera le reste.

Une seule VM Rocky suffit pour ce TP. N'oubliez pas d'ouvrir les ports firewall quand c'est n√©cessaire. De fa√ßon volontaire, je ne le pr√©cise pas √† chaque fois.  
Ca doit devenir naturel : vous lancez un programme pour √©couter sur un port, alors il faut ouvrir ce port.

# Sommaire

- [TP2 : Appr√©hender l'environnement Linux](#tp2--appr√©hender-lenvironnement-linux)
- [Sommaire](#sommaire)
  - [Checklist](#checklist)
- [I. Service SSH](#i-service-ssh)
  - [1. Analyse du service](#1-analyse-du-service)
  - [2. Modification du service](#2-modification-du-service)
- [II. Service HTTP](#ii-service-http)
  - [1. Mise en place](#1-mise-en-place)
  - [2. Analyser la conf de NGINX](#2-analyser-la-conf-de-nginx)
  - [3. D√©ployer un nouveau site web](#3-d√©ployer-un-nouveau-site-web)
- [III. Your own services](#iii-your-own-services)
  - [1. Au cas o√π vous auriez oubli√©](#1-au-cas-o√π-vous-auriez-oubli√©)
  - [2. Analyse des services existants](#2-analyse-des-services-existants)
  - [3. Cr√©ation de service](#3-cr√©ation-de-service)

## Checklist

> Habituez-vous √† voir cette petite checklist, elle figurera dans tous les TPs.

A chaque machine d√©ploy√©e, vous **DEVREZ** v√©rifier la üìù**checklist**üìù :

- [x] IP locale, statique ou dynamique
- [x] hostname d√©fini
- [x] firewall actif, qui ne laisse passer que le strict n√©cessaire
- [x] SSH fonctionnel
- [x] acc√®s Internet (une route par d√©faut, une carte NAT c'est tr√®s bien)
- [x] r√©solution de nom
- [x] SELinux en mode *"permissive"* (v√©rifiez avec `sestatus`, voir [m√©mo install VM tout en bas](https://gitlab.com/it4lik/b1-reseau-2022/-/blob/main/cours/memo/install_vm.md#4-pr%C3%A9parer-la-vm-au-clonage))

**Les √©l√©ments de la üìùchecklistüìù sont STRICTEMENT OBLIGATOIRES √† r√©aliser mais ne doivent PAS figurer dans le rendu.**

![Checklist](./pics/checklist_is_here.jpg)

# I. Service SSH

Le service SSH est d√©j√† install√© sur la machine, et il est aussi d√©j√† d√©marr√© par d√©faut, c'est Rocky qui fait √ßa nativement.

## 1. Analyse du service

On va, dans cette premi√®re partie, analyser le service SSH qui est en cours d'ex√©cution.

üåû **S'assurer que le service `sshd` est d√©marr√©**
```
[elyter@localhost ~]$ systemctl status sshd
‚óè sshd.service - OpenSSH server daemon
     Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
     Active: active (running) since Fri 2022-12-09 11:23:10 EST; 12min ago
       Docs: man:sshd(8)
             man:sshd_config(5)
   Main PID: 701 (sshd)
      Tasks: 1 (limit: 5712)
     Memory: 5.4M
        CPU: 526ms
     CGroup: /system.slice/sshd.service
             ‚îî‚îÄ701 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"

Dec 09 11:28:16 localhost.localdomain sshd[1136]: Connection closed by authenticating user elyter 10.37.132.1 port 58190 [preauth]
Dec 09 11:28:17 localhost.localdomain sshd[1139]: Failed password for elyter from 10.37.132.1 port 58191 ssh2
Dec 09 11:28:18 localhost.localdomain sshd[1139]: Failed password for elyter from 10.37.132.1 port 58191 ssh2
Dec 09 11:28:18 localhost.localdomain sshd[1139]: Connection closed by authenticating user elyter 10.37.132.1 port 58191 [preauth]
Dec 09 11:28:21 localhost.localdomain sshd[1142]: Failed password for elyter from 10.37.132.1 port 58192 ssh2
Dec 09 11:28:21 localhost.localdomain sshd[1142]: Failed password for elyter from 10.37.132.1 port 58192 ssh2
Dec 09 11:28:21 localhost.localdomain sshd[1142]: Connection closed by authenticating user elyter 10.37.132.1 port 58192 [preauth]
Dec 09 11:28:24 localhost.localdomain sshd[1144]: Connection closed by authenticating user elyter 10.37.132.1 port 58193 [preauth]
Dec 09 11:32:06 localhost.localdomain sshd[1209]: Accepted password for elyter from 10.37.132.1 port 58243 ssh2
Dec 09 11:32:06 localhost.localdomain sshd[1209]: pam_unix(sshd:session): session opened for user elyter(uid=1000) by (uid=0)
```
üåû **Analyser les processus li√©s au service SSH**
```
[elyter@localhost ~]$ ps -ef | grep ssh
root         701       1  0 11:23 ?        00:00:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root        1209     701  0 11:32 ?        00:00:00 sshd: elyter [priv]
elyter      1213    1209  0 11:32 ?        00:00:00 sshd: elyter@pts/0
elyter      1288    1214  0 11:38 pts/0    00:00:00 grep --color=auto ssh
```

üåû **D√©terminer le port sur lequel √©coute le service SSH**

```
[elyter@localhost ~]$ sudo ss -ltunp | grep ssh
tcp   LISTEN 0      128          0.0.0.0:22        0.0.0.0:*    users:(("sshd",pid=701,fd=3))   
tcp   LISTEN 0      128             [::]:22           [::]:*    users:(("sshd",pid=701,fd=4))   
```

üåû **Consulter les logs du service SSH**

```
[elyter@localhost log]$ sudo cat secure | grep ssh
Dec  9 10:36:33 localhost sshd[771]: Server listening on 0.0.0.0 port 22.
Dec  9 10:36:33 localhost sshd[771]: Server listening on :: port 22.
Dec  9 10:56:27 localhost sshd[702]: Server listening on 0.0.0.0 port 22.
Dec  9 10:56:27 localhost sshd[702]: Server listening on :: port 22.
Dec  9 11:02:59 localhost sshd[704]: Server listening on 0.0.0.0 port 22.
Dec  9 11:02:59 localhost sshd[704]: Server listening on :: port 22.
Dec  9 11:04:18 localhost sshd[704]: Server listening on 0.0.0.0 port 22.
Dec  9 11:04:18 localhost sshd[704]: Server listening on :: port 22.
Dec  9 11:23:10 localhost sshd[701]: Server listening on 0.0.0.0 port 22.
Dec  9 11:23:10 localhost sshd[701]: Server listening on :: port 22.
Dec  9 11:27:53 localhost sshd[1129]: Connection closed by authenticating user elyter 10.37.132.1 port 58187 [preauth]
Dec  9 11:28:01 localhost sshd[1131]: Connection closed by authenticating user elyter 10.37.132.1 port 58188 [preauth]
Dec  9 11:28:07 localhost sshd[1133]: Invalid user eliott from 10.37.132.1 port 58189
Dec  9 11:28:09 localhost sshd[1133]: Failed none for invalid user eliott from 10.37.132.1 port 58189 ssh2
Dec  9 11:28:09 localhost sshd[1133]: Connection closed by invalid user eliott 10.37.132.1 port 58189 [preauth]
Dec  9 11:28:13 localhost sshd[1136]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=10.37.132.1  user=elyter
Dec  9 11:28:15 localhost sshd[1136]: Failed password for elyter from 10.37.132.1 port 58190 ssh2
Dec  9 11:28:16 localhost sshd[1136]: Connection closed by authenticating user elyter 10.37.132.1 port 58190 [preauth]
Dec  9 11:28:17 localhost sshd[1139]: Failed password for elyter from 10.37.132.1 port 58191 ssh2
Dec  9 11:28:18 localhost sshd[1139]: Failed password for elyter from 10.37.132.1 port 58191 ssh2
Dec  9 11:28:18 localhost sshd[1139]: Connection closed by authenticating user elyter 10.37.132.1 port 58191 [preauth]
Dec  9 11:28:21 localhost sshd[1142]: Failed password for elyter from 10.37.132.1 port 58192 ssh2
Dec  9 11:28:21 localhost sshd[1142]: Failed password for elyter from 10.37.132.1 port 58192 ssh2
Dec  9 11:28:21 localhost sshd[1142]: Connection closed by authenticating user elyter 10.37.132.1 port 58192 [preauth]
Dec  9 11:28:24 localhost sshd[1144]: Connection closed by authenticating user elyter 10.37.132.1 port 58193 [preauth]
Dec  9 11:32:06 localhost sshd[1209]: Accepted password for elyter from 10.37.132.1 port 58243 ssh2
Dec  9 11:32:06 localhost sshd[1209]: pam_unix(sshd:session): session opened for user elyter(uid=1000) by (uid=0)
```

## 2. Modification du service

Dans cette section, on va aller visiter et modifier le fichier de configuration du serveur SSH.

Comme tout fichier de configuration, celui de SSH se trouve dans le dossier `/etc/`.

Plus pr√©cis√©ment, il existe un sous-dossier `/etc/ssh/` qui contient toute la configuration relative au protocole SSH

üåû **Identifier le fichier de configuration du serveur SSH**

üåû **Modifier le fichier de conf**

- ex√©cutez un `echo $RANDOM` pour demander √† votre shell de vous fournir un nombre al√©atoire
  - simplement pour vous montrer la petite astuce et vous faire manipuler le shell :)
- changez le port d'√©coute du serveur SSH pour qu'il √©coute sur ce num√©ro de port
  - dans le compte-rendu je veux un `cat` du fichier de conf
  - filtr√© par un `| grep` pour mettre en √©vidence la ligne que vous avez modifi√©
- g√©rer le firewall
  - fermer l'ancien port
  - ouvrir le nouveau port
  - v√©rifier avec un `firewall-cmd --list-all` que le port est bien ouvert
    - vous filtrerez la sortie de la commande avec un `| grep TEXTE`

üåû **Red√©marrer le service**

- avec une commande `systemctl restart`

üåû **Effectuer une connexion SSH sur le nouveau port**

- depuis votre PC
- il faudra utiliser une option √† la commande `ssh` pour vous connecter √† la VM

> Je vous conseille de remettre le port par d√©faut une fois que cette partie est termin√©e.

‚ú® **Bonus : affiner la conf du serveur SSH**

- faites vos plus belles recherches internet pour am√©liorer la conf de SSH
- par "am√©liorer" on entend essentiellement ici : augmenter son niveau de s√©curit√©
- le but c'est pas de me rendre 10000 lignes de conf que vous pompez sur internet pour le bonus, mais de vous √©veiller √† divers aspects de SSH, la s√©cu ou d'autres choses li√©es

![Such a hacker](./pics/such_a_hacker.png)

# II. Service HTTP

Dans cette partie, on ne va pas se limiter √† un service d√©j√† pr√©sent sur la machine : on va ajouter un service √† la machine.

On va faire dans le *clasico* et installer un serveur HTTP tr√®s r√©put√© : NGINX.  
Un serveur HTTP permet d'h√©berger des sites web.

Un serveur HTTP (ou "serveur Web") c'est :

- un programme qui √©coute sur un port (ouais √ßa change pas √ßa)
- il permet d'h√©berger des sites web
  - un site web c'est un tas de pages html, js, css
  - un site web c'est aussi parfois du code php, python ou autres, qui indiquent comment le site doit se comporter
- il permet √† des clients de visiter les sites web h√©berg√©s
  - pour √ßa, il faut un client HTTP (par exemple, un navigateur web)
  - le client peut alors se connecter au port du serveur (connu √† l'avance)
  - une fois le tunnel de communication √©tabli, le client effectuera des requ√™tes HTTP
  - le serveur r√©pondra √† l'aide du protocole HTTP

> Une requ√™te HTTP c'est "donne moi tel fichier HTML". Une r√©ponse c'est "voici tel fichier HTML" + le fichier HTML en question.

Ok bon on y va ?

## 1. Mise en place

![nngijgingingingijijnx ?](./pics/njgjgijigngignx.jpg)

üåû **Installer le serveur NGINX**

- je vous laisse faire votre recherche internet
- n'oubliez pas de pr√©ciser que c'est pour "Rocky 9"

üåû **D√©marrer le service NGINX**

üåû **D√©terminer sur quel port tourne NGINX**

- vous devez filtrer la sortie de la commande utilis√©e pour n'afficher que les lignes demand√©es
- ouvrez le port concern√© dans le firewall

> **NB : c'est la derni√®re fois que je signale explicitement la n√©cessit√© d'ouvrir un port dans le firewall.** Vous devrez vous-m√™mes y penser lorsque n√©cessaire. **Toutes les commandes li√©es au firewall doivent malgr√© tout figurer dans le compte-rendu.**

üåû **D√©terminer les processus li√©s √† l'ex√©cution de NGINX**

- vous devez filtrer la sortie de la commande utilis√©e pour n'afficher que les lignes demand√©es

üåû **Euh wait**

- y'a un serveur Web qui tourne l√† ?
- bah... visitez le site web ?
  - ouvrez votre navigateur (sur votre PC) et visitez `http://<IP_VM>:<PORT>`
  - vous pouvez aussi (toujours sur votre PC) utiliser la commande `curl` depuis un terminal pour faire une requ√™te HTTP
- dans le compte-rendu, je veux le `curl` (pas un screen de navigateur)
  - utilisez Git Bash si vous √™tes sous Windows (obligatoire)
  - vous utiliserez `| head` apr√®s le `curl` pour afficher que certaines des premi√®res lignes
  - vous utiliserez une option √† cette commande `head` pour afficher les 7 premi√®res lignes de la sortie du `curl`

## 2. Analyser la conf de NGINX

üåû **D√©terminer le path du fichier de configuration de NGINX**

- faites un `ls -al <PATH_VERS_LE_FICHIER>` pour le compte-rendu

üåû **Trouver dans le fichier de conf**

- les lignes qui permettent de faire tourner un site web d'accueil (la page moche que vous avez vu avec votre navigateur)
  - ce que vous cherchez, c'est un bloc `server { }` dans le fichier de conf
  - vous ferez un `cat <FICHIER> | grep <TEXTE> -A X` pour me montrer les lignes concern√©es dans le compte-rendu
    - l'option `-A X` permet d'afficher aussi les `X` lignes apr√®s chaque ligne trouv√©e par `grep`
- une ligne qui parle d'inclure d'autres fichiers de conf
  - encore un `cat <FICHIER> | grep <TEXTE>`
  - bah ouais, on stocke pas toute la conf dans un seul fichier, sinon √ßa serait le bordel

## 3. D√©ployer un nouveau site web

üåû **Cr√©er un site web**

- bon on est pas en cours de design ici, alors on va faire simplissime
- cr√©er un sous-dossier dans `/var/www/`
  - par convention, on stocke les sites web dans `/var/www/`
  - votre dossier doit porter le nom `tp2_linux`
- dans ce dossier `/var/www/tp2_linux`, cr√©ez un fichier `index.html`
  - il doit contenir `<h1>MEOW mon premier serveur web</h1>`

üåû **Adapter la conf NGINX**

- dans le fichier de conf principal
  - vous supprimerez le bloc `server {}` rep√©r√© plus t√¥t pour que NGINX ne serve plus le site par d√©faut
  - red√©marrez NGINX pour que les changements prennent effet
- cr√©ez un nouveau fichier de conf
  - il doit √™tre nomm√© correctement
  - il doit √™tre plac√© dans le bon dossier
  - c'est quoi un "nom correct" et "le bon dossier" ?
    - bah vous avez rep√©r√© dans la partie d'avant les fichiers qui sont inclus par le fichier de conf principal non ?
    - cr√©ez votre fichier en cons√©quence
  - red√©marrez NGINX pour que les changements prennent effet
  - le contenu doit √™tre le suivant :

```nginx
server {
  # le port choisi devra √™tre obtenu avec un 'echo $RANDOM' l√† encore
  listen <PORT>;

  root /var/www/tp2_linux;
}
```

üåû **Visitez votre super site web**

- toujours avec une commande `curl` depuis votre PC (ou un navigateur)

# III. Your own services

Dans cette partie, on va cr√©er notre propre service :)

HE ! Vous vous souvenez de `netcat` ou `nc` ? Le ptit machin de notre premier cours de r√©seau ? C'EST L'HEURE DE LE RESORTIR DES PLACARDS.

## 1. Au cas o√π vous auriez oubli√©

Au cas o√π vous auriez oubli√©, une petite partie qui ne doit pas figurer dans le compte-rendu, pour vous remettre `nc` en main.

‚ûú Dans la VM

- `nc -l 8888`
  - lance netcat en mode listen
  - il √©coute sur le port 8888
  - sans rien pr√©ciser de plus, c'est le port 8888 TCP qui est utilis√©

‚ûú Allumez une autre VM vite fait

- `nc <IP_PREMIERE_VM> 8888`
- v√©rifiez que vous pouvez envoyer des messages dans les deux sens

> Oubliez pas d'ouvrir le port 8888/tcp de la premi√®re VM bien s√ªr :)

## 2. Analyse des services existants

Un service c'est quoi concr√®tement ? C'est juste un processus, que le syst√®me lance, et dont il s'occupe apr√®s.

Il est d√©fini dans un simple fichier texte, qui contient une info primordiale : la commande ex√©cut√©e quand on "start" le service.

Il est possible de d√©finir beaucoup d'autres param√®tres optionnels afin que notre service s'ex√©cute dans de bonnes conditions.

üåû **Afficher le fichier de service SSH**

- vous pouvez obtenir son chemin avec un `systemctl status <SERVICE>`
- mettez en √©vidence la ligne qui commence par `ExecStart=`
  - encore un `cat <FICHIER> | grep <TEXTE>`
  - c'est la ligne qui d√©finit la commande lanc√©e lorsqu'on "start" le service
    - taper `systemctl start <SERVICE>` ou ex√©cuter cette commande √† la main, c'est (presque) pareil

üåû **Afficher le fichier de service NGINX**

- mettez en √©vidence la ligne qui commence par `ExecStart=`

## 3. Cr√©ation de service

![Create service](./pics/create_service.png)

Bon ! On va cr√©er un petit service qui lance un `nc`. Et vous allez tout de suite voir pourquoi c'est pratique d'en faire un service et pas juste le lancer √† la min.

Ca reste un truc pour s'exercer, c'pas non plus le truc le plus utile de l'ann√©e que de mettre un `nc` dans un service n_n

üåû **Cr√©ez le fichier `/etc/systemd/system/tp2_nc.service`**

- son contenu doit √™tre le suivant (nice & easy)

```service
[Unit]
Description=Super netcat tout fou

[Service]
ExecStart=/usr/bin/nc -l <PORT>
```

> Vous remplacerez `<PORT>` par un num√©ro de port random obtenu avec la m√™me m√©thode que pr√©c√©demment.

üåû **Indiquer au syst√®me qu'on a modifi√© les fichiers de service**

- la commande c'est `sudo systemctl daemon-reload`

üåû **D√©marrer notre service de ouf**

- avec une commande `systemctl start`

üåû **V√©rifier que √ßa fonctionne**

- v√©rifier que le service tourne avec un `systemctl status <SERVICE>`
- v√©rifier que `nc` √©coute bien derri√®re un port avec un `ss`
  - vous filtrerez avec un `| grep` la sortie de la commande pour n'afficher que les lignes int√©ressantes
- v√©rifer que juste √ßa marche en vous connectant au service depuis une autre VM
  - allumez une autre VM vite fait et vous tapez une commande `nc` pour vous connecter √† la premi√®re

> **Normalement**, dans ce TP, vous vous connectez depuis votre PC avec un `nc` vers la VM, mais bon. Vos supers OS Windows/MacOS chient un peu sur les conventions de r√©seau, et √ßa marche pas super super en utilisant un `nc` directement sur votre machine. Donc voil√†, allons au plus simple : allumez vite fait une deuxi√®me qui servira de client pour tester la connexion √† votre service `tp2_nc`.

‚ûú Si vous vous connectez avec le client, que vous envoyez √©ventuellement des messages, et que vous quittez `nc` avec un CTRL+C, alors vous pourrez constater que le service s'est stopp√©

- bah oui, c'est le comportement de `nc` √ßa ! 
- le client se connecte, et quand il se tire, √ßa ferme `nc` c√¥t√© serveur aussi
- faut le relancer si vous voulez retester !

üåû **Les logs de votre service**

- mais euh, √ßa s'affiche o√π les messages envoy√©s par le client ? Dans les logs !
- `sudo journalctl -xe -u tp2_nc` pour visualiser les logs de votre service
- `sudo journalctl -xe -u tp2_nc -f ` pour visualiser **en temps r√©el** les logs de votre service
  - `-f` comme follow (on "suit" l'arriv√©e des logs en temps r√©el)
- dans le compte-rendu je veux
  - une commande `journalctl` filtr√©e avec `grep` qui affiche la ligne qui indique le d√©marrage du service
  - une commande `journalctl` filtr√©e avec `grep` qui affiche un message re√ßu qui a √©t√© envoy√© par le client
  - une commande `journalctl` filtr√©e avec `grep` qui affiche la ligne qui indique l'arr√™t du service

üåû **Affiner la d√©finition du service**

- faire en sorte que le service red√©marre automatiquement s'il se termine
  - comme √ßa, quand un client se co, puis se tire, le service se relancera tout seul
  - ajoutez `Restart=always` dans la section `[Service]` de votre service
  - n'oubliez pas d'indiquer au syst√®me que vous avez modifi√© les fichiers de service :)